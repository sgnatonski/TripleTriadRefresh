// Generated by CoffeeScript 1.3.3

/*
Knockout Kinetic plugin version 0.1.4
Copyright 2012 Christopher Currie - https://github.com/christophercurrie
License: MIT (http://www.opensource.org/licenses/mit-license.php)
*/


(function() {
  var __hasProp = {}.hasOwnProperty;

  (function(factory) {
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
      return factory(require('knockout'), exports);
    } else if (typeof define === 'function' && define['amd']) {
      return define(['knockout', 'exports'], factory);
    } else {
      return factory(ko, ko.kinetic = {});
    }
  })(function(ko, exports) {
    var applyAnimations, applyEvents, ctor, expandConfig, makeBindingHandler, nodeFactory, nodeType, redraw, register;
    expandConfig = function(config) {
      var key, realValue, result, value, _ref;
      result = {};
      _ref = ko.utils.unwrapObservable(config);
      for (key in _ref) {
        value = _ref[key];
        realValue = ko.utils.unwrapObservable(value);
        if (typeof realValue !== 'undefined') {
          result[key] = realValue;
        }
      }
      return result;
    };
    applyAnimations = function(node, animations) {
      var key, value, _fn;
      _fn = function(key, value) {
        var fn, trans;
        trans = null;
        if (typeof node[key] === 'function') {
          fn = function(value) {
            try {
              return node[key](value);
            } catch (error) {

            }
          };
          if (ko.isSubscribable(value)) {
            return value.subscribe(function(newValue) {
              if (trans) {
                trans.stop();
              }
              if (newValue) {
                return trans = fn(newValue);
              }
            });
          } else {
            if (value != null) {
              return fn(value);
            }
          }
        }
      };
      for (key in animations) {
        if (!__hasProp.call(animations, key)) continue;
        value = animations[key];
        _fn(key, value);
      }
    };
    applyEvents = function(node, element, events) {
      var key, value, _fn;
      _fn = function(key, value) {
        return node.on(key, function(evt) {
          return value(element, evt);
        });
      };
      for (key in events) {
        if (!__hasProp.call(events, key)) continue;
        value = events[key];
        _fn(key, value);
      }
    };
    redraw = function(node) {
      var drawTarget, layer;
      if (node.getStage()) {
        drawTarget = (function() {
          var _i, _len, _ref;
          if (node.nodeType === 'Stage') {
            _ref = node.children;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              layer = _ref[_i];
              clearTimeout(layer._kktimeout);
            }
            return node;
          } else {
            return node.getLayer();
          }
        })();
        drawTarget = typeof node.draw === 'function' ? node : node.getLayer();
        clearTimeout(drawTarget._kktimeout);
        return drawTarget._kktimeout = setTimeout((function(drawTarget) {
          return function() {
            return drawTarget.draw();
          };
        })(drawTarget), 1);
      }
    };
    makeBindingHandler = function(nodeFactory) {
      return {
        init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
          var config, innerContext, node, parentNode;
          config = expandConfig(valueAccessor());
          node = nodeFactory(config, element.parentNode);
          innerContext = bindingContext.createChildContext(viewModel);
          ko.utils.extend(innerContext, {
            parentNode: node
          });
          ko.applyBindingsToDescendants(innerContext, element);
          parentNode = bindingContext.parentNode;
          if (parentNode) {
            parentNode.add(node);
            ko.utils.domNodeDisposal.addDisposeCallback(element, (function(node) {
              return function() {
                var child, parent, _i, _len, _ref, _results;
                parent = node.getParent();
                if (!parent) {
                  return;
                }
                _ref = parent.children;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  child = _ref[_i];
                  if (!(child === node)) {
                    continue;
                  }
                  parent.remove(node);
                  redraw(parent);
                  break;
                }
                return _results;
              };
            })(node));
          }
          if (element.style) {
            element.style.display = 'none';
          }
          element._kk = node;
          applyAnimations(node, allBindingsAccessor()['animate']);
          applyEvents(node, element, allBindingsAccessor()['events']);
          return {
            controlsDescendantBindings: true
          };
        },
        update: function(element, valueAccessor) {
          var config, node;
          node = element._kk;
          config = expandConfig(valueAccessor());
          node.setAttrs(config);
          return redraw(node);
        }
      };
    };
    register = function(name, factory) {
      ko.bindingHandlers[name] = makeBindingHandler(factory);
      return ko.virtualElements.allowedBindings[name] = true;
    };
    exports['knockout-kinetic'] || (exports['knockout-kinetic'] = {});
    exports['knockout-kinetic']['register'] = register;
    for (nodeType in Kinetic) {
      ctor = Kinetic[nodeType];
      if (!(typeof ctor === 'function')) {
        continue;
      }
      nodeFactory = (function(nodeType, ctor) {
        if (nodeType === 'Stage') {
          return function(config, parent) {
            config['container'] = parent;
            return new ctor(config);
          };
        } else {
          return function(config) {
            return new ctor(config);
          };
        }
      })(nodeType, ctor);
      register("Kinetic." + nodeType, nodeFactory);
    }
  });

}).call(this);
